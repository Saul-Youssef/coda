% $Id: preview.tex,v 1.19 1998/06/22 08:07:00 ohl Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\NeedsTeXFormat{LaTeX2e}
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[margin=1.0in]{geometry}
\usepackage{amscd}
\usepackage{epsfig}
\allowdisplaybreaks
\setlength{\unitlength}{1mm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeindex
\begin{document}
\title{Pure Data Foundations of Mathematics}
\author{%
  Saul Youssef%
  \hfil \\
  Department of Physics \\
  Boston University \\
  youssef@bu.edu\\
}
\maketitle
\begin{abstract}
This is an abstract.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\section{Foundation} 

     Any system of reasoning must necessarily have at least one foundational concept which is understood before a first definition.  In our case, the foundational concept is the {\bf finite sequence}.  We assume that finite sequences and obvious operations on finite sequences are understood.  On the other hand, logic, logical values and predicates (foundational in ZFC) and types (foundational in type theories) are not assumed to be understood.  These will be defined in terms of finite sequences as we proceed.   
Taking finite sequences as understood, we can define ``data'' and ``coda'' by the following. 
\begin{enumerate}
\item[] A {\bf data} is a finite sequence of {\bf codas}.
\item[] A {\bf coda} is a pair of {\bf data}.
\end{enumerate}
Notationally speaking, if $A$ and $B$ are data, $A\ B$ denotes the concatenation of $A$ and $B$ as finite sequences and $A:B$ denotes the data 
consisting of the single coda formed by pairing $A$ and $B$.  For examples, the empty sequence of codas () is data, the pairing 
of two empty sequences $(:)$ is data and this sequence of three 
codas  (:)(:)((:):(:)(:)) is data consisting of a sequence of three codas.  This it ``pure data, made of nothing."  It is the central concept of coda.  
We shall see that both data in the ordinary sense (bits, bytes, language expressions) and mathematical concepts such as variables, functions, definitions, logical values, categories, morphisms, types and theorems appear as varieties of pure data with simple definitions in terms of the small algebra of data $A\ B$ and $A:B$.   In this algebra, we conventionally hold that colons bind from the right first and less strongly than concatenation, so $A:B:C$ means $(A:(B:C))$ and $A:B\ C$ means $(A:(B\ C))$.

     The mathematical content of coda is embodied in a partial function from coda to data called a {\bf context}.  Given a context $\delta$ data equality is defined by the relations 
\begin{enumerate}
\item[] $A\ B = \delta(A)\ B = A\ \delta(B)$
\item[] $A:B = \delta(A):B = A:\delta(B)$
\end{enumerate}
for data $A$ and all data $B$.  Here the partial function $\delta$ is extended to a function from data to data with identities.  Conceptually, relations are assumed until ``$=$" has the same 
properties as the identity. 
      
    The important concept of ``atoms" and ``atomic data'' provides both stability, and a mechanism for adding new definitions to a valid context.   
Given a context $\delta$, an {\it atom} is a coda $c$ where $(c,c)\in \delta$.  Data with atoms in it's sequence are called {\it atomic} data.  In a context $\delta$ with corresponding equality, 
a {\it definition on atom $a$} is a partial function from coda to data where the domain of the partial function is contained within the codas $(a\ A:B)$ for the atom $a$ and for any data $A$ and $B$.  
The axiom below defines how definitions may be added to a {\it valid} context without clashes.  

\newtheorem*{remark}{AXIOM OF DEFINITION} 

\begin{remark}  The context $(:)\rightarrow(:)$ is valid.  If $a$ is an atom in context $\delta$, if $\delta_a$ is a definition on $a$, and if $\delta$ and $\delta_a$ have disjoint domains, then 
the union of $\delta$ and $\delta_a$ is a valid context. 
\end{remark} 
\noindent The point of the initial context $(:)\rightarrow(:)$ is to establish $(:)$ as an initial atom.  
In a typical case, a definition $\delta_a$ will be added to a context when $a$ has not been used by some other definition, thus 
avoiding a clash.  The disjoint requirement also insures the stability of atoms.  Once a coda is an atom in some context, it remains an atom independent of future added definitions.   
We say that atomic data is ``always atomic" and, similarly empty data is ``always empty".  This stability is the basis for an internal logic and it also makes 
it convenient to define a stable 0-bit, 1-bit, stable bit sequences, stable byte sequences in addition to definitions as shown in figure 1.  

As a formal axiomatic system, coda has only one axiom: The Axiom of Definition.  We shall see in the following sections that coda has an internal logic making logic-related 
axioms unnecessary.  Also, coda has an internal language, making axioms related to language and syntax unnecessary.  Unlike type systems with the Curry-Howard 
correspondence, proof and computation in coda are the same thing.  Each is merely a data sequence $A_0=A_1=A_2=\dots=A_n$ either computing $A_n$ from $A_0$ or establishing 
that $A_0=A_n$ depending on one's point of view. 

Unless otherwise indicated, ``data'' refers to pure data and ``sequence'' refers to a finite sequence.  If data $A=()$, we say that $A$ is {\it empty}.  

\section{Logic}

Within coda, items with mathematical meaning are merely pure data of different kinds.  This means, roughly speaking, that mathematical questions will appear in the form 
\begin{itemize}
\item[] Is data $A$ equal to data $B$?
\end{itemize}
Since equality itself will also be definition in context, the answer to the question $A=B$ is also data.  But if everything about $A=B$ is encoded in the concrete data $(= A:B)$, then 
this specific data should contain any ``logical" interpretation of $A=B$.  This suggests that ``logic'' in should be identified as a suitable coarsest non-trivial classification of data which is stable under 
added definitions.  This motivates the following definitions.
\begin{itemize}
\item data is {\bf true} if it is empty.
\item data is {\bf false} if it is atomic. 
\item data is {\bf undecided} otherwise. 
\end{itemize}
Examples illustrate the flavor of this classification.  
\begin{itemize}
\item[] {\bf True:} (), (pass:), (null:a b c), (null: (foo:bar)).
\item[] {\bf False:} (:), a b c, pass : a b c, a b c (foo:bar).
\item[] {\bf Undefined:}  (foo:bar), (pass:foo:bar), (foo:1 2 3).
\end{itemize}
This logic can be thought of as ``not quite two valued'' where undefined data like (foo:bar) represents data which is currently undefined, but which may receive a value if more definitions are added to the current context.  The stability of true or false data under new definitions makes these useful concepts.  We use ``always'' to refer to future definitions as in
\begin{itemize}
\item[--] True data is ``always true.''
\item[--] False data is ``always false.''
\end{itemize}
Undecided data, on the other hand, may become true or false, depending upon future definitions.  Also, as we will see, there is 
also undecided data which can never become true or false with any choice of future definitions.  Such data is called {\bf undecidable}.  
This will be discussed further in section X. 

    Although the logic of coda is not the same as classical logic, we will argue that this is the ``correct'' logic for reasoning in general.  It is also quite close to classical logic in the sense that there is a definition that corresponds to each of the familiar 16 binary operations of classical propositional logic.  For instance, when data $A$ and $B$ are either true or false, the data $({\rm XOR}\ A:B)$ has the value $()$ for {\it true} and $(:)$ for {\it false} depending on the classical truth table of values for XOR.  If either $A$ or $B$ are undecided, on the other hand, no definition applies to $({\rm XOR}\ A:B)$ and it ``waits for $A$ and $B$ to be resolved in future definitions."
    
\section{Language}


\section{Proof and Computation}
\section{Spaces}
\section{Is Mathematics consistent?}
\section{Mathematical Machine Learning}
\section{Summary} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% \bibliography{jpsi}
\begin{thebibliography}{10}
\bibitem{cox} R.T.Cox, Am.J.Phys. 14, 1 (1946).
\bibitem{mpl2} S.Youssef, Mod.Phys.Lett A9, 2571 (1994).
\bibitem{pl} S.Youssef, Phys.Lett. A204, 181(1995).

\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
