#
#   Various "functors" making spaces from existing spaces 
#
#   The Demo notebook has demonstrations 
#  
#   If U is a space, and n is an atom, then 
#
#   (One n : U) is the space of (n:u) for u in U.
#   (Seq n : U) is the space of sequences of (b:u).
#   (Two n : U) is the space of pairs 
#   (End U : X) is an endomorphism of U for any X
#
def One : {prod (:put A) (:B) (:get A)} 
def Seq : {ap  prod (:put A) (:B) (:get A)} 
#
def End :  {prod (:A) (:B) (:A)}
def Down : {prod (:put A) (:B) (:get A)}
#
#  
#
def _Slice : {prod (:put bin) (:B) (:get bin) (:nth A)} 
def _Pair : {sum (:_Slice 1:get bin:nth 1:B) (:_Slice 2:get bin:nth 2:B)}
def Product : { Down A : (_Pair:B) }
#
#
def Two : {Product A : (:B) (:B)}
#
#   General commutator with two co-args and co-inputs 
#
#    U*V = V*U, U:V:X = V:U:X for all X
#
def commutator : ap {bool:((get:first:A)*(get:last:A):get:B)=((get:last:A)*(get:first:A):get:B)}
#
#    U:U:X = U:X for all X.  Each space must be idempotent.
#
Def idempotent : ap {bool:(A:get:B)=(A:A:get:B)}
#
#    U:U:X = X for all X.
#
Def involution : ap {bool:(get:B)=(A:A:get:B)} 
#
#   Spaces must be idempotent as well as satisfying space 
#
Def space : {bool:((A:get:B)=(A:(A:head 1:get:B) (A:tail 1:get:B)))}  
