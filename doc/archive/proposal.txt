

Elements of the system:

An equivalence relation (or "rule") is specified by a coda (eq L:R) where L and R are
data which are guaranteed to be invariant in the current given context.  This means that
you can traverse L and R using the python methods in data.py directly.

We can establish two types of atoms to represent "variables" in the rule.  In the current
compiler, I will write, say

1. eq (ap $A: $b $B) : ($A:$b) (ap $A:$B)
2. eq (ap $A:) : ()
3. eq (ap $A: $B $C) : (ap $A:$B) (ap $A:$C)

This gets compiled into three codas (eq L1:R1) (eq L2:R2) (eq L3:R3).  Here $A is syntactic
sugar for the coda ($:A) in the actual python object.  In other words, "variables" in the
sense of defining the rule are exactly $-atoms.  If the right side of the $-atom.  The
case of the right hand side determines whether it is a variable to be replaced by any
data or a variable to be replaced by any atom.

Examples:
    ($:X) --> a variable that can be replaced by any data, for instance a b c, 1 2 3, or ()
    ($:x) --> a variable that can be replaced by any invariant atom, e.g., a, b, c, &, (:), etc.

Each (eq L:R) defines an equivalence relation on data generated by

   L(<assignment>) ~ R(<assignment>)

for any assignment to the data and atom variables in L and R.

The idea is that a sequence eqs = (eq L1:R1) (eq L2:R2) ... (eq Ln:Rn) defines
an equivalence relation on data, which implies a function

   simplify(eqs,D) = Ds

which satisfies D ~ Ds and where Ds is as simplifies as possible given space/time/processor
constraints. I have in mind that this can be done with some fancy e-graph algorithms.

The idea is to scope any particular collection of eqs within with-atoms.

(with eqs : D)

"with" itself, would be a definition in the current system
defined by the pseudocode

def With(context,domain,A,B):
   let A = (with eqs)
   B2 = simplify(eqs,B)
   return B2
CONTEXT.define('with',With)

Note that simplify has to work recursively because in

(with eqs : D)

D may contain other (with eqs2:D2) data.  For instance,

(with eqs1 : .... (with eqs2:D)...)

then D should be simplified with within the union of eqs1 and eqs2,
the equivalence generated by (eqs1 eqs2), in other words.

   Of course, the meaning of "simplify" has to be defined, and it should
actually simplify as much as possible given time/space/processor limits,
which must be available in "simplify" by some means that I have not defined.

Let's discuss before you write simplify.  Does this look feasible?  As me
any questions you need to clarify.
