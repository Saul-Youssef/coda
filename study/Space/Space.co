#
#   Various "functors" making spaces from existing spaces 
#
#   The Demo notebook has demonstrations 
#  
#   If U is a space, and n is an atom, then 
#
#   (One n : U) is the space of (n:u) for u in U.
#   (Seq n : U) is the space of sequences of (b:u).
#   (Two n : U) is the space of pairs 
#   (End U : X) is an endomorphism of U for any X
#
def One : {prod (:put A) (:B) (:get A)} 
def Seq : {ap  prod (:put A) (:B) (:get A)} 
#
def End :  {prod (:A) (:B) (:A)}
def Down : {prod (:put A) (:B) (:get A)}
#
#   General commutator with two co-args and co-inputs 
#
#    U*V = V*U, U:V:X = V:U:X for all X
#
def commutator : ap {bool:((get:first:A)*(get:last:A):get:B)=((get:last:A)*(get:first:A):get:B)}
#
#    U:U:X = U:X for all X.  Each space must be idempotent.
#
Def idempotent : ap {bool:(A:get:B)=(A:A:get:B)}
#
#    U:U:X = X for all X.
#
Def involution : ap {bool:(get:B)=(A:A:get:B)} 
#
#
Def nilpotent : ap {bool:(A:get:B)} 
Def identity : ap {bool:(get:B)=(A:get:B)} 
#
#   Spaces must be idempotent as well as satisfying SP  
#
#Def space : {bool:((A:get:B)=(A:(A:head 1:get:B) #(A:tail 1:get:B)))}  
#
#   SP pass : (:(:aaa) (:bbb)) 
#
Def SP : {(A:get:get:B)=((A:(A:get:head 1:get:B) (A:get:tail 1:get:B)))} 
#Def space : {bool:((A:get:B)=(A:(A:head 1:get:B) (A:tail 1:get:B)))}  
