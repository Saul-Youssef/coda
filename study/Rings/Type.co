#
#  Standardized Spaces 
#
#  type/Type   - type creation from input - a "type" in the coda sense
#  sum/Sum     - Abelian sum
#  prod/Prod   - Associative multiplication
#  sort/Sort   - Sort compatible with a partial order
#  class/Class - Equivalence classes of an equivalence relation
#  inv/Inv     - Inverse 
#  invol/Invol - Involution 
#  term/Term   - Terminal output 
#
def type : {(?:type A):B} 
def sum  : {(?:sum  A):B}
def prod : {(?:prod A):B}
def sort : {(?:sort A):B}
def inv  : {(?:inv  A):B}
def quo  : {(?:quo   A):B}
def invol: {(?:invol A):B} 
def term : {(?:term  A):B} 
def equiv: {(?:equiv A):B} 

def pro: 
def Product : {ap {put pro (first:A): app (tail:A):B} A : has (first:A) : B}
def product : {ap {nth (tail:A) : sel pro (first:A) : B} A : B}

def cop:
def coproduct: {ap {put cop (first:A) : pre (tail:A) : has (first:A) : B} A : B} 
def _Co1 : {(nth (first : sel cop (first:A) : B) : (tail:A)) : last : sel cop (first:A) : B} 
def Coproduct: {ap _Co1 A : B} 

#
#def type  :    {(Type:A) A : B}
#def sum   :     {(Sum:A) A : B}
#def prod  :    {(Prod:A) A : B}
#def term  :    {(Term:A) A : B}
#def sort  :    {(Sort:A) A : B}
#def inv   :     {(Inv:A) A : B}
#def class :   {(Class:A) A : B}
#def invol :   {(Invol:A) A : B}